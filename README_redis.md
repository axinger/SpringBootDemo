## 安装

```shell
1、检查安装依赖程序

yum install gcc-c++
yum install -y tcl
yum install wget
2、获取安装文件

wget http://download.redis.io/releases/redis-2.8.13.tar.gz
3、解压文件

tar -xzvf redis-2.8.19.tar.gz
mv redis-2.8.19 /usr/local/redis
4、进入目录

cd /usr/local/redis
5、编译安装
make
make install

6、设置配置文件路径
mkdir -p /etc/redis
cp redis.conf /etc/redis

7、修改配置文件

vi /etc/redis/redis.conf
仅修改： daemonize yes （no-->yes）

8、启动
/usr/local/bin/redis-server /etc/redis/redis.conf

9、查看启动
ps -ef | grep redis 

10、使用客户端
redis-cli
>set name david
OK
>get name
"david"

11.关闭客户端
redis-cli shutdown

12、开机启动配置

echo "/usr/local/bin/redis-server /etc/redis/redis.conf &" >> /etc/rc.local
开机启动要配置在 rc.local 中，而 /etc/profile 文件，要有用户登录了，才会被执行。
```

```text
Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
一、String（字符串）

    string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。

    string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。

    string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。

二、Hash（哈希）

    Redis hash 是一个键值(key=>value)对集合。

    Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

    每个 hash 可以存储 232 -1 键值对（40多亿）

三、List（列表）

    Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
    列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。
    他的底层是一个链表

四、Set（集合）

    Redis的Set是string类型的无序集合。

    集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

    集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。

    sadd key member
    添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。
注意：以上实例中 beijing添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。

五、zset(sorted set：有序集合)

    zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
    不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

    zset的成员是唯一的,但分数(score)却可以重复。

```

## 事务

```text
redis事务是一个单独的隔离操作:事务中的所有命令都会序列化,按顺序的执行,
事务在执行过程中,不会被其他客户端发送来的命令请求打断.
主要作用:就是 串联多个命令 防止别的命令插队(秒杀)

开启事务: multi
提交事务:exec
取消:discard

三特性:
1.单独的隔离操作:所有命令都会系列化,an顺序执行,执行过程中,不会被其他客户端命令打断;
2.没有隔离级别的概念:队列中的命令没有提交之前都不会实际执行;
3.不保证原子性:假如有1条命令失败,其他命令仍然执行,没有回滚;
```

```text
组队阶段 > 执行阶段
错误: 
组队阶段错误,都会取消,不执行
执行阶段错误:只取消错的
```

```text
悲观锁: 每次都加锁
乐观锁: 加版本号,用于多度的应用,提高吞吐量;

watch :监听,发现被监听值被修改,就取消操作
```

## 持久化,写入磁盘

```text
RDB: redis data base
默认开启
写实复制技术,建立临时表,进行替换,吞吐量大,完整性一致性要求不高
缺点:最后一次持久化后的数据可能丢失

AOF: 文件追加
记录每个写操作,默认不开启

同时开启,优先AOF

```
```text
1、redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。

2、RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；

3、AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。

4、其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。

5、如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。
————————————————
版权声明：本文为CSDN博主「ljheee」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ljheee/article/details/76284082
```

## 主从复制

```text
master: 写为主
slave: 读为主

读写分离,容灾快速恢复

一主两从特点

从:挂了,重启,从需要再次手动加入主,从头复制主数据
主:挂了,重启,从还是从,主还是主,

主:发生变化时,主动同步给从,而不是从去同步
```

### 薪火相传

```text
主 > 从 > 从
从再同步到从中
```

### 反客为主

```text
主挂了,从升级为主
slaveof no one,
缺点:需要手动设置

哨兵模式:
自动升级主,根据投票数
缺点: 复制延迟

```

## 集群

```text
容量
并发写入
3.0开始 无中心化集群配置
```

## 三个典型问题

### 缓存穿透

```text
现象:
redis没有数据或者非法URL请求大量访问数据库,数据库奔溃;
解决:
1.对空值缓存,设置过期时间很短;
2.设置访问名单,白名单,使用bitmaps类型定义一个访问名单,效率低;
3.布隆过滤器,底层也是bitmaps;
4.进行实时监控;
   
```

### 缓存击穿-某个key过期

```text
现象:
1.数据库访问瞬时压力大;
2.redis没有出现key大量过期,
3,redis正常
原因:
1.redis某个key过期,
解决:
1.预先设置热门数据,提前数据加入redis中
2.实时调整,调整key的过期时长
3.使用锁
```

### 缓存雪崩-大量key过期

```text
现象:
1.数据库压力变大,造成服务器奔溃
原因:
1.极少时间段,查询大量的key集中过期情况;
解决:
1.构建多层缓存架构, Nginx缓存+redis缓存+其他缓存(ehcache等)
2.使用锁或者队列,不适用高并发情况;
3.设置过期标准更新缓存,当key快要过期,提前通知另外的县城更新key缓存;
4.将缓存失效时间分散开;

```

## 分布式锁

```text
SETNX 命令

1.setnx k v 返回1 表示成功 返回0表示不能添加修改值,需要释放锁
2.del k 释放锁
3.锁需要设置过期时间
4.上锁之后,异常,还未设置过期时间;一边上锁,同时设置过期时间,命令: set user 10 nx ex 12 


误删锁
1.a 服务器卡顿,锁过期,被b拿到
2.a 又恢复了,会执行删除锁,就会把b的锁误删
使用UUID 解决
释放锁,判断uuid释放和加锁的时候一样的

保证原子性
1.  a 在删除锁时候,比较了uuid,,正要删除,还没有删除时候,锁到了过期时间,自动释放锁;
2. b 获取到锁, 因为a已经比较了uuid, a就会又删除b锁,缺乏原子性(本人操作不会被打算,就是原子性)

使用LUA脚本
```

## 6.0 新功能

```text
ACL: 访问控制列表,对用户进行更细粒度的权限控制;

```

```text
https://www.toutiao.com/i7055563801969574430/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1642839896&app=news_article&utm_source=weixin&utm_medium=toutiao_ios&use_new_style=1&req_id=20220122162456010212100092266D1572&share_token=669442B5-4948-4D1F-BF93-1D51ABF795B9&group_id=7055563801969574430&wid=1642844917446
01 缓存雪崩
1.1 什么是缓存雪崩？

如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。
1.2 缓存雪崩问题分析

造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？
1.3 缓存雪崩解决方案

（1）事前

① 均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。

② 分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。

③ 热点数据缓存永远不过期。

    永不过期实际包含两层意思：

    物理不过期，针对热点key不设置过期时间

    逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

④ 保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。

（2）事中

① 互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降

② 使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。

（3）事后

① 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。
02 缓存击穿
2.1 什么是缓存击穿？

缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。
2.2 缓存击穿问题分析

关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。
2.3 缓存击穿解决方案

（1）在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降

（2）热点数据缓存永远不过期。

永不过期实际包含两层意思：

    物理不过期，针对热点key不设置过期时间
    逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

03 缓存穿透
3.1 什么是缓存穿透？

缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。
3.2 问题分析

缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿的根本区别在于传进来的key在Redis中是不存在的。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示。
Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级

3.3 解决方法

（1）将无效的key存放进Redis中：

当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value="null"，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。

（2）使用布隆过滤器：

如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。
Redis总结：缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级

    如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。

04 缓存预热
4.1 什么是缓存预热？

缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。

如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。
4.2 缓存预热解决方案

（1）数据量不大的时候，工程启动的时候进行加载缓存动作；

（2）数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；

（3）数据量太大的时候，优先保证热点数据进行提前加载到缓存。
05 缓存降级

缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。

在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。
```